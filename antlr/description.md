<p> ANTLR(ANother Tool for Language Recognition) считается одним из самых мощных синтаксических анализаторов на сегодня. Его главной особенностью является то, что он основан на нисходящем алгоритме синтаксического разбора LL(k). Написан на java, портирован на несколько популярных языков. В качестве результата анализа выдаёт дерево разбора. </p>

<p> Не смотря на то, что ANTLR использует LL(k) алгоритм, он умеет обрабатывать грамматики с левой рекурсией. Для этого он под капотом переделывает введённую пользователем грамматику. Однако, правое ветвление анализировать он всё же не умеет. Но это уже не является большим минусом, как если бы он не мог обработать левую рекурсию. Ведь, в отличии от левой рекурсии, правое ветвление в нормальных грамматиках встречается чрезвычайно редко. </p>

<p> В интерете бытует мнение: "The worst thing about ANTLR is Java". Это вызвано тем, что изначально ANTLR был написан на Java и не собирается далеко от неё уходить. Постепенно он получил поддержку других популярных языков, например C#, Python, C++ или Go. Но синтаксис идеалогически соответствует правилам Java. </p>

# Использование:
- Создать файл *.g4 , в котором будет описана грамматика. Синтаксис описание грамматики есть в документации ANTLR.
- утилитой antlr4 сгенерировать Lexer, Parser, а также опционально Listener и Visitor.
- Написать свою программу, которая с помощью сгенерированных сущностей будет разбирать выражения.

Для разбора выражений пользователем используются два основных паттерна - Visitor и Listener. В целом они схожи, так как представляют собой обход дерева. Заменяют друг друга в зависимости от грамматики, которую мы хотим разбирать.

- Visitor представляет собой обычный обход дерева. Основная идея: стоим в вершине(context), рекурсивно разбираем её детей(то есть считаем части выражения, которое разбираем сейчас). Затем получаем результат текущего выражения. Возвращаем его. В сгенерированном grammarVisitor будет класс, от которого нужно отнаследоваться, чтобы получить доступ к методам visitExpr, а также просто visit, который определит какой из visitExpr нужно вызвать и вызовет его.
- Listener также обходит дерево. Однако здесь пользователь выступает не тем, кто обходит(visitor), а тем кому "доносят информацию". Также наследуемся от grammarListener и получаем доступ к методам enterExpr и exirExpr. Они будут вызываться соответственно на входе и выходе в вершины дерева разбора. Пользователь обрабатывает выражения исходя из этой информации, а также информации в вершине дерева.
Пример: разбор арифметического выражения, используя глобальный стэк.

