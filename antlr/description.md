<p> ANTLR(ANother Tool for Language Recognition) считается одним из самых мощных синтаксических анализаторов на сегодня. Его главной особенностью является то, что он основан на нисходящем алгоритме синтаксического разбора LL(k). Написан на java, портирован на несколько популярных языков. В качестве результата анализа выдаёт дерево разбора. </p>

<p> Не смотря на то, что ANTLR использует LL(k) алгоритм, он умеет обрабатывать грамматики с явной и неявной левой рекурсией(как, например, грамматика arithmetic). Для этого он под капотом переделывает введённую пользователем грамматику. Однако, взаимную левую рекурсию анализировать он всё же не умеет(например грамматику psp он разбирать не умеет, о чём сообщает при запуске). Но это уже не является большим минусом, ведь в отличии от остальных, взаимная в нормальных грамматиках встречается чрезвычайно редко. А также алгоритм избавления от взаимной левой рекурсии в худшем случае работает эспоненциально долго, поэтому его и не стали добавлять. </p>

<p> В интерете бытует мнение: "The worst thing about ANTLR is Java". Это вызвано тем, что изначально ANTLR был написан на Java и не собирается далеко от неё уходить. Постепенно он получил поддержку других популярных языков, например C#, Python, C++ или Go. Но синтаксис идеалогически соответствует правилам Java. </p>

# Использование:
- Создать файл `*.g4` , в котором будет описана грамматика. Синтаксис описание грамматики есть в документации ANTLR.
- утилитой `antlr4` сгенерировать Lexer, Parser, а также опционально Listener и Visitor.
- Написать свою программу, которая с помощью сгенерированных сущностей будет разбирать выражения.

Для разбора выражений пользователем используются два основных паттерна - Visitor и Listener. В целом они схожи, так как представляют собой обход дерева. Заменяют друг друга в зависимости от грамматики, которую мы хотим разбирать.

- Visitor представляет собой обычный обход дерева. Основная идея: стоим в вершине(context), рекурсивно разбираем её детей(то есть считаем части выражения, которое разбираем сейчас). Затем получаем результат текущего выражения. Возвращаем его. В сгенерированном grammarVisitor будет класс, от которого нужно отнаследоваться, чтобы получить доступ к методам `visitExpr`, а также просто `visit`, который определит какой из `visitExpr` нужно вызвать и вызовет его.
- Listener также обходит дерево. Однако здесь пользователь выступает не тем, кто обходит(visitor), а тем кому "доносят информацию". Также наследуемся от `grammarListener` и получаем доступ к методам `enterExpr` и `exirExpr`. Они будут вызываться соответственно на входе и выходе в вершины дерева разбора. Пользователь обрабатывает выражения исходя из этой информации, а также информации в вершине дерева.
Пример: разбор арифметического выражения, используя глобальный стэк.

# Особенности синтаксиса:
- Используя слово fragment, можно задавать псевдонимы каким-то конструкциям. Напримет, написав `fragment NUM : (0-9)+`, можно далее использовать NUM, подразумевая под этим последовательность цифр, но язык не будет считать это токеном.
- Токеном WS принято указывать символы, которые грамматике следует игнорировать. Для этого после определения пишется `-> skip`.
- Правилам разбора можно задавать имена под каждый случай, как это сделано в `arithmetic.g4` для expr. Тогда генератор создаст под каждое имя отдельную функцию в Visitor или Listener. 