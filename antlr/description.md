<p> ANTLR(ANother Tool for Language Recognition) считается одним из самых мощных синтаксических анализаторов на сегодня. Его главной особенностью является то, что он основан на нисходящем алгоритме синтаксического разбора LL(*). Написан на java, портирован на несколько популярных языков. В качестве результата анализа выдаёт дерево разбора. </p>

<p> Не смотря на то, что ANTLR использует LL(k) алгоритм, он умеет обрабатывать грамматики с явной и неявной левой рекурсией. Для этого он под капотом переделывает введённую пользователем грамматику. Однако, взаимную левую рекурсию анализировать он всё же не умеет. Но это уже не является большим минусом, ведь в отличии от остальных, взаимная в нормальных грамматиках встречается чрезвычайно редко. А также алгоритм избавления от взаимной левой рекурсии в худшем случае работает эспоненциально долго, поэтому его и не стали добавлять. </p>

<p> В интерете бытует мнение: "The worst thing about ANTLR is Java". Это вызвано тем, что изначально ANTLR был написан на Java и не собирается далеко от неё уходить. Постепенно он получил поддержку других популярных языков, например C#, Python, C++ или Go. Но синтаксис идеалогически соответствует правилам Java. </p>

# Использование:
- Создать файл `*.g4` , в котором будет описана грамматика. Важно: имя файла должно соответствовать названию грамматики.
- утилитой `antlr4` сгенерировать Lexer, Parser, а также опционально Listener и Visitor.
- Написать свою программу, которая с помощью сгенерированных сущностей будет разбирать выражения.

Для разбора выражений пользователем используются два основных паттерна - Visitor и Listener. В целом они схожи, так как представляют собой обход дерева. Заменяют друг друга в зависимости от грамматики, которую мы хотим разбирать.

- Visitor представляет собой обычный обход дерева. Основная идея: стоим в вершине(context), рекурсивно разбираем её детей(то есть считаем части выражения, которое разбираем сейчас). Затем получаем результат текущего выражения. Возвращаем его. В сгенерированном grammarVisitor будет класс, от которого нужно отнаследоваться, чтобы получить доступ к методам `visitExpr`, а также просто `visit`, который определит какой из `visitExpr` нужно вызвать и вызовет его.
- Listener также обходит дерево. Однако здесь пользователь выступает не тем, кто обходит(visitor), а тем кому "доносят информацию". Также наследуемся от `grammarListener` и получаем доступ к методам `enterExpr` и `exirExpr`. Они будут вызываться соответственно на входе и выходе в вершины дерева разбора. Пользователь обрабатывает выражения исходя из этой информации, а также информации в вершине дерева.
Пример: разбор арифметического выражения, используя глобальный стэк.

# Особенности синтаксиса:
- строчными буквами обозначаются имена нетерминалов, заглавными - имена токенов.
- Используя слово fragment, можно задавать псевдонимы каким-то конструкциям. Напримет, написав `fragment NUM : (0-9)+ ;`, можно далее использовать NUM, подразумевая под этим последовательность цифр, но язык не будет считать это токеном.
- Токеном WS принято указывать символы, которые грамматике следует игнорировать. Для этого после определения пишется `-> skip ;`.
- Правилам разбора можно задавать имена под каждый случай, как это сделано в `arithmetic.g4` для expr. Тогда генератор создаст под каждое имя отдельную функцию в Visitor или Listener. 
- Поддерживает около-регулярные кострукции в описании правил, например `*`, `?` или `+` чтобы обозначать количество.

# Примеры грамматик
- Грамматика arithmetic представляет собой арифметические выражения с целыми числами, поддерживающие скобки. В ней есть прямая левая рекурсия, однако antlr4 умеет её разрешать, поэтому всё ок. Для неё я написал `arithmetic.py`, который, используя сгенерированные antlr4 Lexer, Parser и Visitor, вычисляет значения выражений. 
- Грамматика arithmetic2 также представляет собой арифметические выражения с целыми числами, однако она реализована более оптимально. Это отразилось на скорости работы(в тестах видно). Аналогично для неё написал `arithmetic.py` с паттерном Visitor, вычисляющий значение выражения.
- Грамматика psp_mutual представляет собой язык дика с круглыми и квадратынми скобками, где после закрывающией скобки одного вида не может идти закрывающая другого вида. В этой грамматике есть взаимная левая рекурсия, поэтому antlr4 не сможет с ней работать, о чём и сообщит нам при попытке запуска.
- Грамматика psp представляет собой самый обычный язык ПСП, записанный без левой или взаимной рекурссии. С такой грамматикой проблем у antlr4 уже не возникнет. Для неё я написал `psp.py`, который методом Listener обходит дерево вывода, подсчитывая кол-во ПСП и скобок.