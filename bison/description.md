**Bison** - это генератор лексических анализаторов, который преобразует описание контекстно-свободной LALR(1) грамматики в программу на языке C для разбора этой грамматики.
Bison обратно совместим с Yacc: все правильные грамматики Yacc должны без изменений работать с Bison.

Bison может работать не со всеми контекстно-свободными грамматиками, а только с грамматиками класса LALR(1). Коротко, это означает, что должно быть возможно определить, как разобрать любую часть входа, заглядывая вперёд не более, чем на одну лексему. 

Одной из самых сильных, но в то же время раздражающих сторон является то, что Bison не будет анализировать двусмысленную грамматику. А именно парсер, который создаёт Bison, имеет ровно один способ анализа любых входных данных. И парсер примет именнно эту грамматику. Если грамматика неоднозначна, Bison сообщает о конфликтах, где есть два разных возможных синтаксических анализа для данного куска ввода. Он все равно создает синтаксический анализатор, выбирая один вариант в каждом конфликте, но этот выбор означает, что язык, который он анализирует, не обязательно тот, о котором вы думали.

# Использование
1. Написать лексический анализатор, который будет обрабатывать входной текст и передавать лексемы анализатору. Я использовал `flex lexer.l`
2. Описать грамматику, которую будет распознавать Bison. Для каждого правила грамматики нужно описать действия, которые будут совершаться для этого правила. Действия пишутся на С. Чтобы скомпилировать описание грамматики на Bison `bison -d parser.y`. Ключ `-d` нужен для того, чтобы появился header файл, которым будет пользоваться flex.
3. Наконец нужно с помощью gcc собрать два объектных С файла, которые нам выдали предыдущие два шага: `gcc -o calc lex.yy.c parser.tab.c -lfl -lm`
4. Теперь можно написать `./calc` и тестировать наш парсер.

# Про написанные грамматики
- Простая и неоптимальная арифметика: есть пример `ambiguous.in`, который показывает, что с неоднозначной грамматикой ответ может быть неправильным. Примеры по типу `ones.in`, в которых порядка 25000 символов, выдавали результат `Memory exhausted`. Оказалось, что у Bison по умолчанию установлена глубина стека всего лишь 200. Директива препроцессора помогла побороть это `#define YYINITDEPTH 1000000`. Но к сожалению большим тестам, у которых появлялась вложенность (например `no-paren.in`), не хватало и такого размера стека, а его еще большее увеличение приводило к `Segmentation fault`. Времена работы на каждом тесте есть в файлах в папке `output`.
  
- Оптимальная и однозначная грамматика: из отличий, она справилась посчитать `paren.in` очень быстро.
